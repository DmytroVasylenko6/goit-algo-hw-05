## Завдання 1

Додати метод delete для видалення пар ключ-значення таблиці HashTable , яка реалізована в конспекті.

## Завдання 2

Реалізувати двійковий пошук для відсортованого масиву з дробовими числами. Написана функція для двійкового пошуку повинна повертати кортеж, де першим елементом є кількість ітерацій, потрібних для знаходження елемента. Другим елементом має бути "верхня межа" — це найменший елемент, який є більшим або рівним заданому значенню.

## Завдання 3

Порівняти ефективність алгоритмів пошуку підрядка: Боєра-Мура, Кнута-Морріса-Пратта та Рабіна-Карпа на основі двох текстових файлів ([стаття 1](https://drive.google.com/file/d/18_R5vEQ3eDuy2VdV3K5Lu-R-B-adxXZh/view), [стаття 2](https://drive.google.com/file/d/13hSt4JkJc11nckZZz2yoFHYL89a4XkMZ/view)). Використовуючи timeit, треба виміряти час виконання кожного алгоритму для двох видів підрядків: одного, що дійсно існує в тексті, та іншого — вигаданого (вибір підрядків за вашим бажанням). На основі отриманих даних визначити найшвидший алгоритм для кожного тексту окремо та в цілому.


## Висновки щодо швидкостей алгоритмів

### Вступ:

У сфері комп'ютерних наук ефективність пошукових алгоритмів є темою першорядної важливості. Ці алгоритми, призначені для пошуку певних елементів у масивах даних, забезпечують основну функціональність інформаційно-пошукових систем. У цьому есе ми коротко розглянемо показники ефективності трьох відомих пошукових алгоритмів: алгоритм пошуку Кнута-Морріса-Пратта (КМП), флгоритм пошуку Бойєра-Мура та алгоритм пошуку Рабіна-Карпа.

### Алгоритмічне протистояння:

У таблиці нижче представлено знімок продуктивності кожного алгоритму, виміряний з точки зору швидкості:

✅ Підхід 1

|   Algorithm types   |  Speed   |
|---------------------|----------| 
| kmp_search          |  0.09402 |
| boyer_moore_search  |  0.03353 |
| rabin_karp_search   |  0.23868 |

Найшвидший алгоритм пошуку ***з збігами***: boyer_moore_search за загальним часом:: 0.03353 сек

|   Algorithm types   |  Speed   |
|---------------------|----------| 
| kmp_search          |  0.10273 |
| boyer_moore_search  |  0.04247 |
| rabin_karp_search   |  0.25414 |

Найшвидший алгоритм пошуку ***без співпадінь***: boyer_moore_search із загальним часом: 0.04247 сек

✅ Підхід 2

|   Algorithm types   |  Speed   |
|--------------------|----------| 
| kmp_search          |  0.13374 |
| boyer_moore_search  |  0.04827 |
| rabin_karp_search   |  0.32073 |

Найшвидший алгоритм пошуку ***iз співпадіннями***: boyer_moore_search із загальним часом: 0.04827 сек

|   Algorithm types   |  Speed   |
|--------------------|----------| 
| kmp_search          |  0.15841 |
| boyer_moore_search  |  0.06271 |
| rabin_karp_search   |  0.37585 |

Найшвидший алгоритм пошуку ***без співпадінь***: boyer_moore_search із загальним часом: 0.0627 сек

**Найшвидший алгоритм:**

З наведених даних видно, що алгоритм пошуку Бойєра-Мура виділяється як найшвидший, маючи вражаючий загальний час виконання *0.05837* та *0.07385* секунд.

При цьому позиція (на початку, в середині, в кінці) підрядка для пошуку не має суттєвого впливу на результати

## Фактори, що впливають на швидкість:

На швидкість роботи пошукових алгоритмів впливають кілька факторів:

- ***Методи зіставлення шаблонів:*** Кожен алгоритм використовує унікальні методи зіставлення шаблонів. Бойє-Мур, відомий своїми ефективними порівняннями символів та евристикою стрибків, демонструє чудову швидкість у певних сценаріях.

- ***Алгоритмічна складність:*** Часова складність алгоритму, яка часто виражається в нотації Big O, дає уявлення про його ефективність. Лінійна часова складність алгоритму Бойєра-Мура робить його високопродуктивним, особливо для великих наборів даних.

- ***Адаптивність:*** Адаптивність алгоритму до різних типів даних впливає на його загальну швидкість. Адаптивність методу Бойєра-Мура до різних шаблонів сприяє його стабільній роботі з різними наборами даних.